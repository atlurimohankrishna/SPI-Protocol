### **SPI (Serial Peripheral Interface) Protocol**
SPI (Serial Peripheral Interface) is a synchronous serial communication protocol primarily used for short-distance communication between microcontrollers and peripherals like sensors, memory devices, and display controllers. It was developed by Motorola and is widely used in embedded systems due to its high speed and simplicity.

---

### **SPI Architecture**
SPI follows a master-slave architecture, where a single master device communicates with one or multiple slave devices. It typically uses four main signals:

1. **SCLK (Serial Clock)** – Clock signal generated by the master to synchronize data transfer.
2. **MOSI (Master Out Slave In)** – Data line for sending data from master to slave.
3. **MISO (Master In Slave Out)** – Data line for sending data from slave to master.
4. **SS/CS (Slave Select/Chip Select)** – Used by the master to select a specific slave device.

---

### **SPI Communication Process**
1. **Master generates the clock signal**: The frequency of the clock determines the data transfer speed.
2. **Data transmission**: 
   - The master sends data to the slave via MOSI.
   - The slave can simultaneously send data back via MISO.
3. **Full-duplex communication**: Since SPI supports simultaneous data transmission and reception, it is faster than half-duplex protocols like I²C.
4. **Slave selection**: The master selects the target slave by pulling its **CS** line low.

---

### **SPI Modes**
SPI has four modes (Mode 0 to Mode 3) based on two parameters:
- **Clock Polarity (CPOL)** – Determines the idle state of the clock.
- **Clock Phase (CPHA)** – Determines when data is sampled.

| Mode | CPOL | CPHA | Clock Edge |
|------|------|------|------------|
| 0    | 0    | 0    | Rising edge sample, falling edge shift |
| 1    | 0    | 1    | Falling edge sample, rising edge shift |
| 2    | 1    | 0    | Falling edge sample, rising edge shift |
| 3    | 1    | 1    | Rising edge sample, falling edge shift |

---

### **Advantages of SPI**
- **High-speed communication** (higher than I²C).
- **Full-duplex capability** for simultaneous data transfer.
- **Simple hardware design** (fewer lines than parallel communication).
- **Low power consumption** compared to parallel interfaces.

### **Disadvantages of SPI**
- **Requires more pins** than I²C (one per slave device for CS).
- **No built-in acknowledgment** (unlike I²C).
- **Short-distance communication** (not ideal for long-range data transfer).

---

### **Applications of SPI**
1. **Embedded Systems**: Communication between microcontrollers and sensors (e.g., temperature sensors, accelerometers).
2. **Display Interfaces**: Controlling OLED, LCD, and touchscreen displays.
3. **Memory Devices**: Flash memory (NOR, NAND), EEPROMs, and SD cards.
4. **Industrial Automation**: Connecting ADCs, DACs, and motor controllers.
5. **Consumer Electronics**: Used in digital cameras, smartwatches, and gaming controllers.
6. **Automotive Systems**: Communication with vehicle sensors and infotainment systems.

SPI is a fast, efficient, and widely used protocol in embedded systems where high-speed data transfer is essential. However, for applications requiring multiple devices on a single bus, I²C might be a better choice due to its addressing mechanism.
---

### **Verilog code for SPI Master Module**
```verilog
// SPI Master Module
module spi_master (
    input logic clk,
    input logic reset,
    input logic [7:0] master_data,
    input logic start,
    output logic sclk,
    output logic mosi,
    output logic cs,
    output logic busy
);

    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            sclk <= 1'b0;
            cs <= 1'b1;
            mosi <= 1'b0;
            busy <= 1'b0;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else if (start && !busy) begin
            cs <= 1'b0;
            busy <= 1'b1;
            shift_reg <= master_data;
            bit_count <= 3'd7;
        end else if (busy) begin
            sclk <= ~sclk;
            if (sclk) begin // Send data on the rising edge of SCLK
                mosi <= shift_reg[7];
                shift_reg <= {shift_reg[6:0], 1'b0};
                if (bit_count == 0) begin
                    cs <= 1'b1;
                    busy <= 1'b0;
                end else begin
                    bit_count <= bit_count - 1;
                end
            end
        end
    end
endmodule
```
---

### **Verilog code for SPI Slave Module**
```verilog
// SPI Slave Module
module spi_slave (
    input logic clk,
    input logic reset,
    input logic sclk,
    input logic mosi,
    input logic cs,
    output logic [7:0] slave_data
);

    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            slave_data <= 8'd0;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else if (!cs) begin
            if (sclk) begin// Capture data on the rising edge of SCLK 
                shift_reg <= {shift_reg[6:0], mosi};
                if (bit_count == 3'd7) begin
                    slave_data <= {shift_reg[6:0], mosi};
                    bit_count <= 3'd0;
                end else begin
                    bit_count <= bit_count + 1;
                end
            end
        end
    end
endmodule

```
---

### **SystemVerilog Testbench code**
```systemverilog
// Testbench for SPI Communication
module tb_spi;
    logic clk;
    logic reset;
    logic start;
    logic [7:0] master_data;
    logic sclk, mosi, cs, busy;
    logic [7:0] slave_data;

    // Instantiate SPI Master
    spi_master master_inst (
        .clk(clk),
        .reset(reset),
        .master_data(master_data),
        .start(start),
        .sclk(sclk),
        .mosi(mosi),
        .cs(cs),
        .busy(busy)
    );

    // Instantiate SPI Slave
    spi_slave slave_inst (
        .clk(clk),
        .reset(reset),
        .sclk(sclk),
        .mosi(mosi),
        .cs(cs),
        .slave_data(slave_data)
    );

    // Clock Generation
    initial clk = 0;
    always #5 clk = ~clk; // 100 MHz clock

    // Test Sequence
    initial begin
        reset = 1;
        start = 0;
        master_data = 8'hA5;
        #20 reset = 0;
        #10 start = 1;
        #10 start = 0;

        wait (!busy); // Wait for SPI transfer to complete
        #50;
        $display("Received data: %h", slave_data);
        $finish;
    end
endmodule
```
